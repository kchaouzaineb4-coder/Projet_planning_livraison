


streamlit
pandas
numpy
plotly
openpyxl
fpdf


                 Backend.py

import pandas as pd
import math
import numpy as np # Import pour g√©rer les NaN plus efficacement

# --- Constantes pour la location de camion ---
SEUIL_POIDS = 3000.0    # kg
SEUIL_VOLUME = 9.216    # m¬≥ (ex: 2.4 * 2.4 * 0.8 * 2 = 9.216)
CAMION_CODE = "CAMION-LOUE"

class TruckRentalProcessor:
    """
    Classe pour g√©rer la logique de proposition et de d√©cision de location de camion
    bas√©e sur les donn√©es optimis√©es.
    """
    
    def __init__(self, df_optimized):
        """Initialise le processeur avec le DataFrame de base pour la gestion des propositions."""
        self.df_base = self._initialize_rental_columns(df_optimized.copy())
        # Initialiser le compteur de camions lou√©s pour g√©n√©rer C1, C2, etc.
        # On commence √† 1 + le nombre de camions lou√©s d√©j√† pr√©sents si on chargeait un √©tat
        self._next_camion_num = self.df_base[self.df_base["Code V√©hicule"] == CAMION_CODE].shape[0] + 1

    def _initialize_rental_columns(self, df):
        """Ajoute les colonnes d'√©tat de location si elles n'existent pas et les renomme."""
        
        # Colonnes √† renommer pour la coh√©rence interne et la gestion des d√©cisions
        df.rename(columns={
            "Poids total charg√©": "Poids total",
            "Volume total charg√©": "Volume total",
            "Client(s) inclus": "Client commande",
            "Repr√©sentant(s) inclus": "Repr√©sentant"
        }, inplace=True)

        # Assurer que les colonnes de d√©cision existent
        if "Location_camion" not in df.columns:
            df["Location_camion"] = False
        if "Location_proposee" not in df.columns:
            df["Location_proposee"] = False
        if "Code V√©hicule" not in df.columns:
            df["Code V√©hicule"] = "ESTAFETTE" # Valeur par d√©faut
        if "Camion N¬∞" not in df.columns:
            # Ce Camion N¬∞ initial sera √©cras√© par le N¬∞ d'Estafette pour les lignes optimis√©es
            df["Camion N¬∞"] = df["Estafette N¬∞"].apply(lambda x: f"E{int(x)}" if pd.notna(x) and x != 0 else "√Ä Optimiser")
        
        # Mettre √† jour les "Camion N¬∞" pour les lignes de location (si d√©j√† l√†)
        mask_camion_loue = df["Code V√©hicule"] == CAMION_CODE
        if mask_camion_loue.any():
            # Assigner C1, C2, C3... en fonction de l'ordre d'apparition
            df.loc[mask_camion_loue, "Camion N¬∞"] = [f"C{i+1}" for i in range(mask_camion_loue.sum())]

        # S'assurer que les BLs sont bien des cha√Ænes
        df['BL inclus'] = df['BL inclus'].astype(str)
        
        # Correction: s'assurer que 'Estafette N¬∞' est num√©rique pour le tri
        df["Estafette N¬∞"] = pd.to_numeric(df["Estafette N¬∞"], errors='coerce').fillna(99999).astype(int)

        return df

    def detecter_propositions(self):
        """
        Regroupe les donn√©es par Client commande pour d√©terminer si le SEUIL est d√©pass√©.
        Retourne un DataFrame des clients proposables.
        """
        # Exclure les clients d√©j√† trait√©s (ceux o√π Location_proposee est True)
        # On utilise le 'Client commande' qui est l'agr√©gation du client
        processed_clients = self.df_base[self.df_base["Location_proposee"]]["Client commande"].unique()
        
        # Filtrer toutes les lignes de df_base pour exclure les commandes des clients d√©j√† trait√©s
        df_pending = self.df_base[~self.df_base["Client commande"].isin(processed_clients)].copy()

        if df_pending.empty:
            return pd.DataFrame() # Retourne un DataFrame vide si tout est d√©j√† trait√©

        # Utiliser df_pending pour l'agr√©gation
        grouped = df_pending.groupby("Client commande").agg(
            Poids_sum=pd.NamedAgg(column="Poids total", aggfunc="sum"),
            Volume_sum=pd.NamedAgg(column="Volume total", aggfunc="sum"),
            Zones=pd.NamedAgg(column="Zone", aggfunc=lambda s: ", ".join(sorted(set(s.astype(str).tolist()))))
        ).reset_index()

        # Filtrage : Poids ou Volume d√©passe le seuil
        propositions = grouped[(grouped["Poids_sum"] >= SEUIL_POIDS) | (grouped["Volume_sum"] >= SEUIL_VOLUME)].copy()

        # Cr√©ation de la colonne Raison
        def get_raison(row):
            raisons = []
            if row["Poids_sum"] >= SEUIL_POIDS:
                raisons.append(f"Poids ‚â• {SEUIL_POIDS} kg")
            if row["Volume_sum"] >= SEUIL_VOLUME:
                raisons.append(f"Volume ‚â• {SEUIL_VOLUME:.3f} m¬≥")
            return " & ".join(raisons)

        propositions["Raison"] = propositions.apply(get_raison, axis=1)
        propositions.rename(columns={
             "Client commande": "Client",
             "Poids_sum": "Poids total (kg)",
             "Volume_sum": "Volume total (m¬≥)",
             "Zones": "Zones concern√©es"
          }, inplace=True)

        return propositions.sort_values(["Poids total (kg)", "Volume total (m¬≥)"], ascending=False).reset_index(drop=True)

    def get_details_client(self, client):
        """R√©cup√®re et formate les d√©tails de tous les BLs/voyages pour un client."""
        # Filtrer en s'assurant que 'Client commande' est bien dans le df
        if "Client commande" not in self.df_base.columns:
             return "Erreur: Colonne 'Client commande' manquante.", pd.DataFrame()
             
        data = self.df_base[self.df_base["Client commande"] == client].copy()
        
        if data.empty:
            return f"Aucune donn√©e pour {client}", pd.DataFrame()

        total_poids = data["Poids total"].sum()
        total_volume = data["Volume total"].sum()
        
        # D√©terminer l'√©tat actuel pour ce client
        etat = "Non d√©cid√©e" 
        
        if (data["Location_camion"]).any():
            etat = "Location ACCEPT√âE"
        elif (data["Location_proposee"]).any():
            etat = "Proposition REFUS√âE"
        
        # Colonnes pour l'affichage des d√©tails (adapt√©es au DataFrame optimis√©)
        colonnes_affichage = [
             "Zone", "Camion N¬∞", "Poids total", "Volume total", "BL inclus", "Taux d'occupation (%)",
             "Client commande", "Repr√©sentant", "Location_camion", "Location_proposee", "Code V√©hicule"
           ]
        
        # R√©organiser et s√©lectionner les colonnes
        data_display = data[[col for col in colonnes_affichage if col in data.columns]]
        
        resume = f"Client {client} ‚Äî Poids total : {total_poids:.1f} kg ; Volume total : {total_volume:.3f} m¬≥ | √âtat : {etat}"
        
        # Formater les colonnes pour l'affichage
        data_display_styled = data_display.style.format({
            "Poids total": "{:.2f} kg",
            "Volume total": "{:.3f} m¬≥",
            "Taux d'occupation (%)": "{:.2f}%"
        }).set_table_attributes('data-table-name="details-client-table"')

        return resume, data_display_styled

    def appliquer_location(self, client, accepter):
        """Applique ou refuse la location pour un client et met √† jour le DataFrame de base."""
        mask = self.df_base["Client commande"] == client
        if not mask.any():
            return False, "Client introuvable.", self.df_base

        df = self.df_base.copy()
        
        # R√©cup√©rer les donn√©es totales (somme de tous les voyages du client)
        poids_total = df.loc[mask, "Poids total"].sum()
        volume_total = df.loc[mask, "Volume total"].sum()
        bl_concat = ";".join(df.loc[mask, "BL inclus"].astype(str).unique().tolist())
        representants = ";".join(sorted(df.loc[mask, "Repr√©sentant"].astype(str).unique().tolist()))
        zones = ";".join(sorted(df.loc[mask, "Zone"].astype(str).unique().tolist()))
        
        # Taux d'occupation (bas√© sur des seuils plus importants pour le camion lou√©)
        TAUX_POIDS_MAX_LOC = 5000 # kg, par exemple 
        TAUX_VOLUME_MAX_LOC = 15 # m3, par exemple
        
        taux_occu = max(poids_total / TAUX_POIDS_MAX_LOC * 100, volume_total / TAUX_VOLUME_MAX_LOC * 100)
        
        if accepter:
            # --- MODIFICATION CL√â ICI ---
            # 1. G√©n√©rer le num√©ro de camion C1, C2, C3...
            camion_num_final = f"C{self._next_camion_num}"
            
            # 2. Cr√©er un nouveau voyage (une seule ligne) pour le camion lou√©
            new_row = pd.DataFrame([{
                "Zone": zones,
                "Estafette N¬∞": 0, # Mettre √† 0 pour le tri
                "Poids total": poids_total,
                "Volume total": volume_total,
                "BL inclus": bl_concat,
                "Client commande": client,
                "Repr√©sentant": representants,
                "Location_camion": True,
                "Location_proposee": True,
                "Code V√©hicule": CAMION_CODE,
                "Camion N¬∞": camion_num_final, # Assigner le nouveau num√©ro
                "Taux d'occupation (%)": taux_occu,
            }])
            
            # 3. Mettre √† jour le compteur
            self._next_camion_num += 1

            # 4. Supprimer les lignes d'estafette existantes pour ce client
            df = df[~mask]
            
            # 5. Ajouter la nouvelle ligne
            df = pd.concat([df, new_row], ignore_index=True)
            
            self.df_base = df
            return True, f"‚úÖ Location ACCEPT√âE pour {client}. Les commandes ont √©t√© consolid√©es dans le v√©hicule {camion_num_final}.", self.detecter_propositions()
        else:
            # Refuser la proposition (les commandes restent dans les estafettes optimis√©es)
            # Marquer Location_proposee √† True pour qu'elles n'apparaissent plus
            df.loc[mask, ["Location_proposee", "Location_camion", "Code V√©hicule"]] = [True, False, "ESTAFETTE"]
            
            # Mettre √† jour 'Camion N¬∞' pour s'assurer que c'est bien l'estafette E1, E2...
            df.loc[mask, "Camion N¬∞"] = df.loc[mask, "Estafette N¬∞"].apply(lambda x: f"E{int(x)}")
            
            self.df_base = df
            return True, f"‚ùå Proposition REFUS√âE pour {client}. Les commandes restent r√©parties en Estafettes.", self.detecter_propositions()

    def get_df_result(self):
        """
        Retourne le DataFrame optimis√© final avec les modifications de location.
        Inclut la modification demand√©e : fusion de 'Estafette N¬∞' et 'Camion N¬∞'
        dans la seule colonne 'V√©hicule N¬∞'.
        """
        df_result = self.df_base.copy()
        
        # Renommer les colonnes pour les rendre conformes √† l'affichage final
        df_result.rename(columns={
             "Poids total": "Poids total charg√©",
             "Volume total": "Volume total charg√©",
             "Client commande": "Client(s) inclus",
             "Repr√©sentant": "Repr√©sentant(s) inclus",
             # MODIFICATION DEMAND√âE : Renommer Camion N¬∞ en V√©hicule N¬∞
             "Camion N¬∞": "V√©hicule N¬∞" 
        }, inplace=True)
        
        # Tri final: Les camions lou√©s (Code_Tri=0) en premier, puis les estafettes.
        # Nous utilisons toujours "Estafette N¬∞" pour le tri m√™me si elle sera supprim√©e ensuite.
        df_result['Code_Tri'] = df_result['Code V√©hicule'].apply(lambda x: 0 if x == CAMION_CODE else 1)
        
        # Utiliser 'V√©hicule N¬∞' (qui contient E1, E2 ou C1, C2...) pour le tri des v√©hicules
        df_result = df_result.sort_values(by=["Code_Tri", "Estafette N¬∞", "V√©hicule N¬∞", "Zone"], ascending=[True, True, True, True])

        # Suppression des colonnes de tri et temporaires
        df_result = df_result.drop(columns=['Code_Tri'], errors='ignore')
        
        # MODIFICATION DEMAND√âE : Suppression de la colonne "Estafette N¬∞" du r√©sultat affichable
        df_result = df_result.drop(columns=['Estafette N¬∞'], errors='ignore')
        
        # D√©finition des colonnes finales pour l'affichage (sans Estafette N¬∞ mais avec V√©hicule N¬∞)
        final_cols_display = [
             "Zone", 
             "V√©hicule N¬∞", # Contient maintenant E1, E2, C1, C2...
             "Poids total charg√©", 
             "Volume total charg√©", 
             "Client(s) inclus", 
             "Repr√©sentant(s) inclus", 
             "BL inclus", 
             "Taux d'occupation (%)",
             "Location_camion", 
             "Location_proposee", 
             "Code V√©hicule"
        ]

        # S√©lection des colonnes dans l'ordre final
        return df_result[[col for col in final_cols_display if col in df_result.columns]]


class DeliveryProcessor:

    # =====================================================
    # ‚úÖ Fonction principale : traitement complet
    # =====================================================
    def process_delivery_data(self, liv_file, ydlogist_file, wcliegps_file):
        try:
            # Lecture des fichiers
            df_liv = self._load_livraisons(liv_file)
            df_yd = self._load_ydlogist(ydlogist_file)

            # Filtrage des donn√©es
            df_liv = self._filter_initial_data(df_liv)

            # Calcul Poids & Volume
            df_poids = self._calculate_weights(df_liv)
            df_vol = self._calculate_volumes(df_liv, df_yd)

            # Fusionner poids + volume
            df_merged = self._merge_delivery_data(df_poids, df_vol)

            # Charger le fichier clients/repr√©sentants
            df_clients = self._load_wcliegps(wcliegps_file)

            # Ajouter Client, Ville et Repr√©sentant
            df_final = self._add_city_client_info(df_merged, df_clients)

            # Calcul Volume total en m3
            df_final["Volume de l'US"] = pd.to_numeric(df_final["Volume de l'US"], errors='coerce').fillna(0) / 1_000_000
            df_final["Volume total"] = df_final["Volume de l'US"] * df_final["Quantit√© livr√©e US"]

            # Regroupement par ville et client (pour l'affichage "Livraisons Client/Ville")
            df_grouped, df_city = self._group_data(df_final)

            # Calcul du besoin en estafette par ville
            df_city = self._calculate_estafette_need(df_city)

            # Nouveau tableau : ajout Zone
            df_grouped_zone = self._add_zone(df_grouped.rename(columns={"Client": "Client de l'estafette"}))

            # Filtrer les livraisons avec "Zone inconnue"
            df_grouped_zone = df_grouped_zone[df_grouped_zone["Zone"] != "Zone inconnue"].copy()
            
            # üÜï Groupement par zone
            df_zone = self._group_by_zone(df_grouped_zone)
            
            # üÜï Calcul du besoin en estafette par zone
            df_zone = self._calculate_estafette_need(df_zone)

            # üÜï Calcul des voyages optimis√©s 
            df_optimized_estafettes = self._calculate_optimized_estafette(df_grouped_zone)

            # üÜï Retourne les DataFrames + l'instance TruckRentalProcessor
            return df_grouped, df_city, df_grouped_zone, df_zone, df_optimized_estafettes

        except Exception as e:
            raise Exception(f"‚ùå Erreur lors du traitement des donn√©es : {str(e)}")

    # =====================================================
    # üîπ Chargement des donn√©es
    # =====================================================
    def _load_livraisons(self, liv_file):
        df = pd.read_excel(liv_file)
        
        # ‚úÖ CORRECTION BUG : Renommer la colonne 'N¬∞ BON LIVRAISON' en 'No livraison'
        if 'N¬∞ BON LIVRAISON' in df.columns:
            df.rename(columns={'N¬∞ BON LIVRAISON': 'No livraison'}, inplace=True)
            
        # Renommage de la 5√®me colonne (index 4) en 'Quantit√© livr√©e US'
        if len(df.columns) > 4:
            df.rename(columns={df.columns[4]: "Quantit√© livr√©e US"}, inplace=True)
            
        return df

    def _load_ydlogist(self, file_path):
        df = pd.read_excel(file_path)
        # Renommage des colonnes Unit√© Volume (index 16) et Poids de l'US (index 13)
        if len(df.columns) > 16:
            df.rename(columns={df.columns[16]: "Unit√© Volume"}, inplace=True)
        if len(df.columns) > 13:
            df.rename(columns={df.columns[13]: "Poids de l'US"}, inplace=True)
            
        return df

    def _load_wcliegps(self, wcliegps_file):
        df_clients = pd.read_excel(wcliegps_file)
        
        # Identifier et renommer la colonne Repr√©sentant (index 16, colonne Q)
        if len(df_clients.columns) > 16:
            df_clients.rename(columns={df_clients.columns[16]: "Repr√©sentant"}, inplace=True)
        
        # S'assurer que les colonnes 'Client' et 'Repr√©sentant' existent pour la jointure
        required_cols = ["Client", "Ville", "Repr√©sentant"]
        for col in required_cols:
            if col not in df_clients.columns:
                 # G√©rer le cas o√π la colonne n'a pas √©t√© trouv√©e √† l'index 16
                 if col not in df_clients.columns:
                      raise ValueError(f"La colonne '{col}' est manquante dans le fichier clients. Veuillez v√©rifier le format.")
        
        return df_clients[["Client", "Ville", "Repr√©sentant"]].copy()

    # =====================================================
    # üîπ Filtrage
    # =====================================================
    def _filter_initial_data(self, df):
        clients_exclus = [
             "AMECAP", "SANA", "SOPAL", "SOPALGAZ", "SOPALSERV", "SOPALTEC",
             "SOPALALG", "AQUA", "WINOX", "QUIVEM", "SANISTONE",
             "SOPAMAR", "SOPALAFR", "SOPALINTER"
          ]
        return df[(df["Type livraison"] != "SDC") & (~df["Client commande"].isin(clients_exclus))]

    # =====================================================
    # üîπ Calcul Poids
    # =====================================================
    def _calculate_weights(self, df):
        # Conversion Poids de l'US
        df["Poids de l'US"] = pd.to_numeric(df["Poids de l'US"].astype(str).str.replace(",", ".")
                                             .str.replace(r"[^\d.]", "", regex=True), errors="coerce").fillna(0)
        
        # Conversion Quantit√© livr√©e US
        df["Quantit√© livr√©e US"] = pd.to_numeric(df["Quantit√© livr√©e US"], errors="coerce").fillna(0)
        
        df["Poids total"] = df["Quantit√© livr√©e US"] * df["Poids de l'US"]
        return df[["No livraison", "Article", "Client commande", "Poids total", "Quantit√© livr√©e US", "Poids de l'US"]]

    # =====================================================
    # üîπ Calcul Volume
    # =====================================================
    def _calculate_volumes(self, df_liv, df_art):
        df_liv_sel = df_liv[["No livraison", "Article", "Quantit√© livr√©e US", "Client commande"]]
        df_art_sel = df_art[["Article", "Volume de l'US", "Unit√© Volume"]].copy()
        
        # Conversion Volume de l'US
        df_art_sel["Volume de l'US"] = pd.to_numeric(df_art_sel["Volume de l'US"].astype(str).str.replace(",", "."),
                                                      errors="coerce")
        return pd.merge(df_liv_sel, df_art_sel, on="Article", how="left")

    # =====================================================
    # üîπ Fusion
    # =====================================================
    def _merge_delivery_data(self, df_poids, df_vol):
        # On fusionne avec les colonnes de poids pour garder les colonnes initiales
        return pd.merge(df_poids.drop(columns=["Quantit√© livr√©e US", "Poids de l'US"], errors='ignore'), 
                         df_vol, on=["No livraison", "Article", "Client commande"], how="left")


    # =====================================================
    # üîπ Ajout Client, Ville et Repr√©sentant
    # =====================================================
    def _add_city_client_info(self, df, df_clients):
        # Jointure pour ajouter Ville et Repr√©sentant
        # Attention: 'Client commande' est le code du BL, 'Client' est le code du client dans df_clients
        return pd.merge(df, df_clients[["Client", "Ville", "Repr√©sentant"]],
                         left_on="Client commande", right_on="Client", how="left")

    # =====================================================
    # üîπ Groupement par Livraison/Client/Ville/Repr√©sentant
    # =====================================================
    def _group_data(self, df):
        # La colonne "Client commande" devient "Client" ici pour le regroupement
        df_grouped = df.groupby(["No livraison", "Client", "Ville", "Repr√©sentant"], as_index=False).agg({
            "Article": lambda x: ", ".join(x.astype(str)),
            "Poids total": "sum",
            "Volume total": "sum"
        })
        df_city = df_grouped.groupby("Ville", as_index=False).agg({
            "Poids total": "sum",
            "Volume total": "sum",
            "No livraison": "count"
        }).rename(columns={"No livraison": "Nombre livraisons"})
        return df_grouped, df_city

    # =====================================================
    # üîπ Calcul besoin estafette (Applicable √† Ville ou Zone)
    # =====================================================
    def _calculate_estafette_need(self, df):
        poids_max = 1550 # kg
        volume_max = 4.608 # m3 (1.2 * 1.2 * 0.8 * 4)
        
        if "Poids total" in df.columns and "Volume total" in df.columns:
            df["Besoin estafette (poids)"] = df["Poids total"].apply(lambda p: math.ceil(p / poids_max))
            df["Besoin estafette (volume)"] = df["Volume total"].apply(lambda v: math.ceil(v / volume_max))
            df["Besoin estafette r√©el"] = df[["Besoin estafette (poids)", "Besoin estafette (volume)"]].max(axis=1)
        else:
            print("Colonnes Poids total ou Volume total manquantes pour le calcul estafette.")
        return df

    # =====================================================
    # üîπ Ajout Zone
    # =====================================================
    def _add_zone(self, df):
        zones = {
             "Zone 1": ["TUNIS", "ARIANA", "MANOUBA", "BEN AROUS", "BIZERTE", "MATEUR",
                         "MENZEL BOURGUIBA", "UTIQUE"],
             "Zone 2": ["NABEUL", "HAMMAMET", "KORBA", "MENZEL TEMIME", "KELIBIA", "SOLIMAN"],
             "Zone 3": ["SOUSSE", "MONASTIR", "MAHDIA", "KAIROUAN"],
             "Zone 4": ["GAB√àS", "MEDENINE", "ZARZIS", "DJERBA"],
             "Zone 5": ["GAFSA", "KASSERINE", "TOZEUR", "NEFTA", "DOUZ"],
             "Zone 6": ["JENDOUBA", "B√âJA", "LE KEF", "TABARKA", "SILIANA"],
             "Zone 7": ["SFAX"]
           }

        def get_zone(ville):
            ville = str(ville).upper().strip()
            for z, villes in zones.items():
                if ville in villes:
                    return z
            return "Zone inconnue"

        df["Zone"] = df["Ville"].apply(get_zone)
        return df

    # =====================================================
    # üÜï Groupement par Zone
    # =====================================================
    def _group_by_zone(self, df_grouped_zone):
        df_zone = df_grouped_zone.groupby("Zone", as_index=False).agg({
            "Poids total": "sum",
            "Volume total": "sum",
            "No livraison": "count"
        }).rename(columns={"No livraison": "Nombre livraisons"})
        return df_zone

    # =====================================================
    # üÜï Calcul des voyages optimis√©s par Estafette
    # =====================================================
    def _calculate_optimized_estafette(self, df_grouped_zone):
        # === Capacit√©s max ===
        MAX_POIDS = 1550    # kg
        MAX_VOLUME = 4.608  # m3 (1.2 * 1.2 * 0.8 * 4)

        resultats = []
        estafette_num = 1  # compteur global unique pour les estafettes

        # === Boucle par zone ===
        for zone, group in df_grouped_zone.groupby("Zone"):
            # Trier les BL par poids d√©croissant (heuristique First Fit Decreasing)
            group_sorted = group.sort_values(by="Poids total", ascending=False).reset_index()
            estafettes = []  # liste des estafettes d√©j√† cr√©√©es pour la zone
            
            for idx, row in group_sorted.iterrows():
                bl = str(row["No livraison"])
                poids = row["Poids total"]
                volume = row["Volume total"]
                client = str(row["Client de l'estafette"]) 
                representant = str(row["Repr√©sentant"])
                placed = False
                
                # Chercher la 1√®re estafette o√π √ßa rentre
                for e in estafettes:
                    if e["poids"] + poids <= MAX_POIDS and e["volume"] + volume <= MAX_VOLUME:
                        e["poids"] += poids
                        e["volume"] += volume
                        e["bls"].append(bl)
                        # Ajout du client/repr√©sentant √† l'ensemble (set) pour l'unicit√©
                        for c in client.split(','): e["clients"].add(c.strip())
                        for r in representant.split(','): e["representants"].add(r.strip())
                        placed = True
                        break
                
                # Si aucun emplacement trouv√© -> cr√©er une nouvelle estafette
                if not placed:
                    estafettes.append({
                        "poids": poids,
                        "volume": volume,
                        "bls": [bl],
                        "clients": {c.strip() for c in client.split(',')},
                        "representants": {r.strip() for r in representant.split(',')},
                        "num_global": estafette_num # On assigne le num√©ro global ici
                    })
                    estafette_num += 1 # On incr√©mente le compteur global seulement si on cr√©e une nouvelle estafette

            # Sauvegarder les r√©sultats
            for e in estafettes:
                clients_list = ", ".join(sorted(list(e["clients"])))
                representants_list = ", ".join(sorted(list(e["representants"])))
                resultats.append([
                    zone,
                    e["num_global"], # Utilisation du num√©ro global
                    e["poids"],
                    e["volume"],
                    clients_list,   
                    representants_list,
                    ";".join(e["bls"])
                ])
                
            # === Cr√©er un DataFrame r√©sultat ===
        df_estafettes = pd.DataFrame(resultats, columns=["Zone", "Estafette N¬∞", "Poids total charg√©", "Volume total charg√©", "Client(s) inclus", "Repr√©sentant(s) inclus", "BL inclus"])
        
        # CALCUL DU TAUX D'OCCUPATION
        df_estafettes["Taux Poids (%)"] = (df_estafettes["Poids total charg√©"] / MAX_POIDS) * 100
        df_estafettes["Taux Volume (%)"] = (df_estafettes["Volume total charg√©"] / MAX_VOLUME) * 100
        df_estafettes["Taux d'occupation (%)"] = df_estafettes[["Taux Poids (%)", "Taux Volume (%)"]].max(axis=1).round(2)
        
        # Initialisation des colonnes de location pour le TruckRentalProcessor
        df_estafettes["Location_camion"] = False
        df_estafettes["Location_proposee"] = False
        df_estafettes["Code V√©hicule"] = "ESTAFETTE"
        # La colonne "Camion N¬∞" doit refl√©ter le num√©ro d'Estafette (E1, E2...)
        df_estafettes["Camion N¬∞"] = df_estafettes["Estafette N¬∞"].apply(lambda x: f"E{int(x)}")
        
        # Nettoyage et formatage final
        df_estafettes = df_estafettes.drop(columns=["Taux Poids (%)", "Taux Volume (%)"]) 
        
        return df_estafettes
    # =====================================================
    # üÜï Transfert des BL d'une estafette √† une autre dans la m√™me zone
    # =====================================================
    def transfer_bl_between_estafettes(self, source_estafette_num, target_estafette_num, bl_list):
        """
        Transfert une ou plusieurs BLs d'une estafette source √† une estafette cible
        dans la m√™me zone. Le poids et volume sont recalcul√©s automatiquement.
        
        :param source_estafette_num: Num√©ro de l'estafette source (E1, E2...)
        :param target_estafette_num: Num√©ro de l'estafette cible (E1, E2...)
        :param bl_list: Liste de BLs √† transf√©rer (list ou string s√©par√©s par ;)
        :return: (success: bool, message: str)
        """
        df = self.df_base.copy()
        
        # Normaliser la liste de BL
        if isinstance(bl_list, str):
            bl_list = [b.strip() for b in bl_list.split(';') if b.strip()]
        
        if source_estafette_num == target_estafette_num:
            return False, "‚ùå L'estafette source et cible sont identiques."
        
        # V√©rifier que les deux estafettes existent
        mask_source = df["Camion N¬∞"] == source_estafette_num
        mask_target = df["Camion N¬∞"] == target_estafette_num
        
        if not mask_source.any():
            return False, f"‚ùå Estafette source {source_estafette_num} introuvable."
        if not mask_target.any():
            return False, f"‚ùå Estafette cible {target_estafette_num} introuvable."
        
        # V√©rifier que les BLs existent dans l'estafette source
        bl_source = df.loc[mask_source, "BL inclus"].str.split(';').explode().str.strip()
        if not all(bl in bl_source.values for bl in bl_list):
            return False, "‚ùå Certains BLs n'existent pas dans l'estafette source."
        
        # Transfert BLs
        for bl in bl_list:
            # Retirer le BL de l'estafette source
            df.loc[mask_source, "BL inclus"] = df.loc[mask_source, "BL inclus"].apply(
                lambda x: ";".join([b for b in x.split(';') if b.strip() != bl])
            )
            
            # Ajouter le BL √† l'estafette cible
            df.loc[mask_target, "BL inclus"] = df.loc[mask_target, "BL inclus"].apply(
                lambda x: ";".join(filter(None, list(x.split(';')) + [bl]))
            )
        
        # Recalculer poids et volume pour les deux estafettes
        for estafette_num in [source_estafette_num, target_estafette_num]:
            mask = df["Camion N¬∞"] == estafette_num
            df.loc[mask, "Poids total charg√©"] = df.loc[mask].apply(
                lambda row: sum(
                    df.loc[df["BL inclus"].str.contains(bl.strip(), na=False), "Poids total charg√©"]
                    for bl in row["BL inclus"].split(';') if bl.strip()
                ), axis=1
            )
            df.loc[mask, "Volume total charg√©"] = df.loc[mask].apply(
                lambda row: sum(
                    df.loc[df["BL inclus"].str.contains(bl.strip(), na=False), "Volume total charg√©"]
                    for bl in row["BL inclus"].split(';') if bl.strip()
                ), axis=1
            )
            # Recalcul taux occupation
            df.loc[mask, "Taux d'occupation (%)"] = df.loc[mask].apply(
                lambda row: max(
                    row["Poids total charg√©"] / 1550 * 100,
                    row["Volume total charg√©"] / 4.608 * 100
                ), axis=1
            )
        
        # Mettre √† jour le DataFrame
        self.df_base = df
        return True, f"‚úÖ BLs transf√©r√©s de {source_estafette_num} vers {target_estafette_num} avec succ√®s."
    # ============================================================
    # üîÅ NOUVELLE CLASSE : Gestion du transfert de BLs entre estafettes
    # ============================================================


# =====================================================
# üÜï CLASSE : Gestion du transfert de BLs entre estafettes
# =====================================================

class TruckTransferManager:
    def __init__(self, df_livraisons):
        """
        df_livraisons : DataFrame contenant au moins les colonnes suivantes :
        ['Zone', 'Estafette', 'BL', 'Poids (kg)', 'Volume (m¬≥)']
        """
        self.df = df_livraisons.copy()

    def get_estafettes_in_zone(self, zone):
        """Retourne la liste unique des estafettes dans une zone donn√©e."""
        df_zone = self.df[self.df["Zone"] == zone]
        return sorted(df_zone["Estafette"].dropna().unique().tolist())

    def get_bls_of_estafette(self, zone, estafette):
        """Retourne la liste des BLs associ√©s √† une estafette donn√©e dans une zone."""
        df_filt = self.df[(self.df["Zone"] == zone) & (self.df["Estafette"] == estafette)]
        return sorted(df_filt["BL"].dropna().astype(str).unique().tolist())

    def check_transfer(self, zone, estafette_source, estafette_cible, bls_transfer):
        """
        V√©rifie si le transfert est possible selon les contraintes :
        - poids <= 1550 kg
        - volume <= 4.608 m¬≥
        Retourne : (bool, dict)
        """
        SEUIL_POIDS = 1550
        SEUIL_VOLUME = 4.608

        df_zone = self.df[self.df["Zone"] == zone]

        # Donn√©es source et cible
        df_src = df_zone[df_zone["Estafette"] == estafette_source]
        df_dst = df_zone[df_zone["Estafette"] == estafette_cible]

        # Calcul totaux actuels
        poids_src, vol_src = df_src["Poids (kg)"].sum(), df_src["Volume (m¬≥)"].sum()
        poids_dst, vol_dst = df_dst["Poids (kg)"].sum(), df_dst["Volume (m¬≥)"].sum()

        # BLs √† transf√©rer
        df_bls = df_src[df_src["BL"].astype(str).isin(bls_transfer)]
        poids_bls, vol_bls = df_bls["Poids (kg)"].sum(), df_bls["Volume (m¬≥)"].sum()

        # Simulation du transfert
        poids_src_new = poids_src - poids_bls
        vol_src_new = vol_src - vol_bls
        poids_dst_new = poids_dst + poids_bls
        vol_dst_new = vol_dst + vol_bls

        # V√©rification des seuils
        transfert_autorise = (poids_dst_new <= SEUIL_POIDS) and (vol_dst_new <= SEUIL_VOLUME)

        info = {
            "Zone": zone,
            "Estafette source": estafette_source,
            "Estafette cible": estafette_cible,
            "Poids transf√©r√© (kg)": poids_bls,
            "Volume transf√©r√© (m¬≥)": vol_bls,
            "Poids source avant/apr√®s": f"{poids_src:.2f} ‚Üí {poids_src_new:.2f}",
            "Volume source avant/apr√®s": f"{vol_src:.3f} ‚Üí {vol_src_new:.3f}",
            "Poids cible avant/apr√®s": f"{poids_dst:.2f} ‚Üí {poids_dst_new:.2f}",
            "Volume cible avant/apr√®s": f"{vol_dst:.3f} ‚Üí {vol_dst_new:.3f}",
            "R√©sultat": "‚úÖ TRANSFERT AUTORIS√â" if transfert_autorise else "‚ùå TRANSFERT REFUS√â : CAPACIT√â D√âPASS√âE"
        }

        return transfert_autorise, info



                 APP.PY

import streamlit as st
import pandas as pd
from backend import DeliveryProcessor, TruckRentalProcessor, TruckTransferManager, SEUIL_POIDS, SEUIL_VOLUME 
import plotly.express as px


# =====================================================
# === Fonction show_df pour arrondir √† 3 d√©cimales ===
# =====================================================
def show_df(df, **kwargs):
    """
    Affiche un DataFrame avec tous les nombres arrondis √† 3 d√©cimales.
    kwargs sont transmis √† st.dataframe.
    """
    if isinstance(df, pd.DataFrame):
        df_to_display = df.copy()
        df_to_display = df_to_display.round(3)
        st.dataframe(df_to_display, **kwargs)
    else:
        st.dataframe(df, **kwargs)

# =====================================================
# === Fonction show_df_multiline avec affichage HTML ===
# =====================================================
def show_df_multiline(df, column_to_multiline):
    """
    Affiche un DataFrame avec les articles multilignes dans la m√™me cellule.
    Chaque 'No livraison' reste sur une seule ligne.
    """
    df_display = df.copy()

    # Grouper les lignes par livraison et concat√©ner les articles avec des <br>
    df_display = df_display.groupby(
        ['No livraison', 'Client', 'Ville', 'Repr√©sentant', 'Poids total', 'Volume total'],
        as_index=False
    ).agg({column_to_multiline: lambda x: "<br>".join(x.astype(str))})

    # CSS pour forcer l‚Äôaffichage des <br> sur plusieurs lignes
    css = """
    <style>
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #555;
        padding: 8px;
        text-align: left;
        vertical-align: top;
        white-space: normal;
        word-wrap: break-word;
    }
    th {
        background-color: #222;
        color: white;
    }
    td {
        color: #ddd;
    }
    </style>
    """

    html = df_display.to_html(escape=False, index=False)
    st.markdown(css + html, unsafe_allow_html=True)
# =====================================================
# üìå Constantes pour les v√©hicules et chauffeurs
# =====================================================
VEHICULES_DISPONIBLES = [
    'SLG-VEH11', 'SLG-VEH14', 'SLG-VEH22', 'SLG-VEH19',
    'SLG-VEH10', 'SLG-VEH16', 'SLG-VEH23', 'SLG-VEH08', 'SLG-VEH20', 'code-Camion'
]

CHAUFFEURS_DETAILS = {
    '09254': 'DAMMAK Karim', '06002': 'MAAZOUN Bassem', '11063': 'SASSI Ramzi',
    '10334': 'BOUJELBENE Mohamed', '15144': 'GADDOUR Rami', '08278': 'DAMMAK Wissem',
    '18339': 'REKIK Ahmed', '07250': 'BARKIA Mustapha', '13321': 'BADRI Moez','Matricule': 'Chauffeur Camion'
}

# Configuration page
st.set_page_config(page_title="Planning Livraisons", layout="wide")
st.title("üöö Planning de Livraisons & Optimisation des Tourn√©es")
st.markdown("---")

# =====================================================
# INITIALISATION DE L'√âTAT DE SESSION
# =====================================================
if 'data_processed' not in st.session_state:
    st.session_state.data_processed = False
    st.session_state.df_grouped = None
    st.session_state.df_city = None
    st.session_state.df_grouped_zone = None
    st.session_state.df_zone = None 
    st.session_state.df_optimized_estafettes = None
    st.session_state.rental_processor = None # Objet de traitement de location
    st.session_state.propositions = None # Dataframe de propositions
    st.session_state.selected_client = None # Client s√©lectionn√©
    st.session_state.message = "" # Message de r√©sultat d'op√©ration

# =====================================================
# Fonctions de Callback pour la Location
# =====================================================

def update_propositions_view():
    """Met √† jour le DataFrame de propositions apr√®s une action."""
    if st.session_state.rental_processor:
        st.session_state.propositions = st.session_state.rental_processor.detecter_propositions()
        
        # R√©initialiser la s√©lection si le client n'est plus dans les propositions ouvertes
        if (st.session_state.selected_client is not None and 
            st.session_state.propositions is not None and 
            st.session_state.selected_client not in st.session_state.propositions['Client'].astype(str).tolist()):
            st.session_state.selected_client = None
    else:
        st.session_state.propositions = pd.DataFrame()

def handle_location_action(accepter):
    """G√®re l'acceptation ou le refus de la proposition de location."""
    if st.session_state.rental_processor and st.session_state.selected_client:
        # Assurer que le client est une cha√Æne valide
        client_to_process = str(st.session_state.selected_client)
        ok, msg, _ = st.session_state.rental_processor.appliquer_location(
            client_to_process, accepter=accepter
        )
        st.session_state.message = msg
        update_propositions_view()
        # st.rerun() # Pas besoin de rerun ici car le on_click est d√©j√† dans un bloc de rerender
    elif not st.session_state.selected_client:
        st.session_state.message = "‚ö†Ô∏è Veuillez s√©lectionner un client √† traiter."
    else:
        st.session_state.message = "‚ö†Ô∏è Le processeur de location n'est pas initialis√©."

def accept_location_callback():
    handle_location_action(True)

def refuse_location_callback():
    handle_location_action(False)

# =====================================================
# 1. UPLOAD DES FICHIERS INPUT (Section 1)
# =====================================================
st.header("1. üì• Importation des Donn√©es")

col_file_1, col_file_2, col_file_3, col_button = st.columns([1, 1, 1, 1])
with col_file_1:
    liv_file = st.file_uploader("Fichier Livraisons (BL)", type=["xlsx"])
with col_file_2:
    ydlogist_file = st.file_uploader("Fichier Volumes (Articles)", type=["xlsx"])
with col_file_3:
    wcliegps_file = st.file_uploader("Fichier Clients/Zones", type=["xlsx"])
with col_button:
    # Espace pour le bouton
    st.markdown("<br>", unsafe_allow_html=True) # Petit espace
    if st.button("Ex√©cuter le traitement complet", type="primary"):
        if liv_file and ydlogist_file and wcliegps_file:
            processor = DeliveryProcessor()
            try:
                with st.spinner("Traitement des donn√©es en cours..."):
                    df_grouped, df_city, df_grouped_zone, df_zone, df_optimized_estafettes = processor.process_delivery_data(
                        liv_file, ydlogist_file, wcliegps_file
                    )
                
                # Stockage des r√©sultats dans l'√©tat de session
                st.session_state.df_optimized_estafettes = df_optimized_estafettes
                st.session_state.df_grouped = df_grouped
                st.session_state.df_city = df_city
                st.session_state.df_grouped_zone = df_grouped_zone
                st.session_state.df_zone = df_zone 
                
                # üÜï Initialisation du processeur de location et des propositions
                st.session_state.rental_processor = TruckRentalProcessor(df_optimized_estafettes)
                update_propositions_view()
                
                st.session_state.data_processed = True
                st.session_state.message = "Traitement termin√© avec succ√®s ! Les r√©sultats s'affichent ci-dessous."
                st.rerun() # Rerun pour mettre √† jour l'interface

            except Exception as e:
                st.error(f"‚ùå Erreur lors du traitement : {str(e)}")
                st.session_state.data_processed = False
        else:
            st.warning("Veuillez uploader tous les fichiers n√©cessaires.")
st.markdown("---")

# =====================================================
# AFFICHAGE DES R√âSULTATS (Se d√©clenche si les donn√©es sont trait√©es)
# =====================================================
if st.session_state.data_processed:
    
    # Affichage des messages d'op√©ration
    if st.session_state.message.startswith("‚úÖ"):
        st.success(st.session_state.message)
    elif st.session_state.message.startswith("‚ùå"):
        st.error(st.session_state.message)
    elif st.session_state.message.startswith("‚ö†Ô∏è"):
        st.warning(st.session_state.message)
    else:
        st.info(st.session_state.message or "Pr√™t √† traiter les propositions de location.")
    
    # R√©cup√©ration du DF mis √† jour √† chaque fois
    df_optimized_estafettes = st.session_state.rental_processor.get_df_result() 
    
# =====================================================
# 2. ANALYSE DE LIVRAISON D√âTAILL√âE (Section 2)
# =====================================================
st.header("2. üîç Analyse de Livraison D√©taill√©e")

tab_grouped, tab_city, tab_zone_group, tab_zone_summary, tab_charts = st.tabs([
    "Livraisons Client/Ville", 
    "Besoin Estafette par Ville", 
    "Livraisons Client/Zone", 
    "Besoin Estafette par Zone",
    "Graphiques"
])

# --- Onglet Livraisons Client/Ville ---
with tab_grouped:
    st.subheader("Livraisons par Client & Ville")

    df_liv = st.session_state.df_grouped.drop(columns=["Zone"], errors='ignore').copy()

    # Transformer les articles en liste avec retour √† la ligne
    if "Article" in df_liv.columns:
        df_liv["Article"] = df_liv["Article"].astype(str).apply(lambda x: "<br>".join(a.strip() for a in x.split(",")))

    # Affichage avec HTML dans st.markdown
    st.markdown(
        df_liv.to_html(escape=False, index=False),
        unsafe_allow_html=True
    )

    # Stockage pour la section 5
    if "df_livraisons" not in st.session_state:
        st.session_state.df_livraisons = df_liv.copy()




# --- Onglet Besoin Estafette par Ville ---
with tab_city:
    st.subheader("Besoin Estafette par Ville")
    show_df(st.session_state.df_city, use_container_width=True)

# --- Onglet Livraisons Client & Ville + Zone ---
with tab_zone_group:
    st.subheader("Livraisons par Client & Ville + Zone")
    show_df(st.session_state.df_grouped_zone, use_container_width=True)

# --- Onglet Besoin Estafette par Zone ---
with tab_zone_summary:
    st.subheader("Besoin Estafette par Zone")
    show_df(st.session_state.df_zone, use_container_width=True)

# --- Onglet Graphiques ---
with tab_charts:
    st.subheader("Statistiques par Ville")
    col1, col2 = st.columns(2)
    with col1:
        st.plotly_chart(
            px.bar(st.session_state.df_city, x="Ville", y="Poids total",
                   title="Poids total livr√© par ville"),
            use_container_width=True
        )
    with col2:
        st.plotly_chart(
            px.bar(st.session_state.df_city, x="Ville", y="Volume total",
                   title="Volume total livr√© par ville (m¬≥)"),
            use_container_width=True
        )

    col3, col4 = st.columns(2)
    with col3:
        st.plotly_chart(
            px.bar(st.session_state.df_city, x="Ville", y="Nombre livraisons",
                   title="Nombre de livraisons par ville"),
            use_container_width=True
        )
    with col4:
        st.plotly_chart(
            px.bar(st.session_state.df_city, x="Ville", y="Besoin estafette r√©el",
                   title="Besoin en Estafettes par ville"),
            use_container_width=True
        )

st.markdown("---")

    # =====================================================
# 3. PROPOSITION DE LOCATION DE CAMION (Section 3)
# =====================================================
st.header("3. üöö Proposition de location de camion")
st.markdown(f"üî∏ Si un client d√©passe **{SEUIL_POIDS} kg** ou **{SEUIL_VOLUME} m¬≥**, une location est propos√©e (si non d√©j√† d√©cid√©e).")

if st.session_state.propositions is not None and not st.session_state.propositions.empty:
    col_prop, col_details = st.columns([2, 3])
    
    with col_prop:
        st.markdown("### Propositions ouvertes")
        # Affichage des propositions ouvertes avec show_df
        show_df(
            st.session_state.propositions,
            use_container_width=True,
            column_order=["Client", "Poids total (kg)", "Volume total (m¬≥)", "Raison"],
            hide_index=True
        )
        
        # S√©lection du client (assure qu'un client non None est s√©lectionn√© par d√©faut si possible)
        client_options = st.session_state.propositions['Client'].astype(str).tolist()
        client_options_with_empty = [""] + client_options
        
        # Index de s√©lection par d√©faut
        default_index = 0
        if st.session_state.selected_client in client_options:
             default_index = client_options_with_empty.index(st.session_state.selected_client)
        elif len(client_options) > 0:
             default_index = 1  # S√©lectionne le premier client par d√©faut s'il y en a

        st.session_state.selected_client = st.selectbox(
            "Client √† traiter :", 
            options=client_options_with_empty, 
            index=default_index,
            key='client_select' 
        )

        col_btn_acc, col_btn_ref = st.columns(2)
        is_client_selected = st.session_state.selected_client != ""
        
        with col_btn_acc:
            st.button(
                "‚úÖ Accepter la location", 
                on_click=accept_location_callback, 
                disabled=not is_client_selected,
                use_container_width=True
            )
        with col_btn_ref:
            st.button(
                "‚ùå Refuser la proposition", 
                on_click=refuse_location_callback, 
                disabled=not is_client_selected,
                use_container_width=True
            )

    with col_details:
        st.markdown("### D√©tails de la commande client")
        if is_client_selected:
            resume, details_df_styled = st.session_state.rental_processor.get_details_client(
                st.session_state.selected_client
            )
            st.text(resume)
            # Affichage du DataFrame stylis√© avec show_df pour 3 d√©cimales
            show_df(details_df_styled, use_container_width=True, hide_index=True)
        else:
            st.info("S√©lectionnez un client pour afficher les d√©tails de la commande/estafettes.")
else:
    st.success("üéâ Aucune proposition de location de camion en attente de d√©cision.")

st.markdown("---")

# =====================================================
# 4. VOYAGES PAR ESTAFETTE OPTIMIS√â (Section 4 - R√©sultat final)
# =====================================================
st.header("4. üöê Voyages par Estafette Optimis√© (Inclut Camions Lou√©s)")


# --- Cr√©ation d'une copie pour l'affichage (avec unit√©s) ---
df_display = df_optimized_estafettes.copy()
df_display["Poids total charg√©"] = df_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
df_display["Volume total charg√©"] = df_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
df_display["Taux d'occupation (%)"] = df_display["Taux d'occupation (%)"].map(lambda x: f"{x:.3f}%")

# --- Affichage avec show_df ---
show_df(df_display, use_container_width=True)

# --- Pr√©parer un DataFrame pour export Excel ---
df_export = df_optimized_estafettes.copy()
df_export["Poids total charg√©"] = df_export["Poids total charg√©"].round(3)
df_export["Volume total charg√©"] = df_export["Volume total charg√©"].round(3)

# --- Bouton de t√©l√©chargement Excel ---
from io import BytesIO
path_optimized = "Voyages_Estafette_Optimises.xlsx"
excel_buffer = BytesIO()
with pd.ExcelWriter(excel_buffer, engine='openpyxl') as writer:
    df_export.to_excel(writer, index=False, sheet_name="Voyages Optimis√©s")
excel_buffer.seek(0)

st.download_button(
    label="üíæ T√©l√©charger Voyages Estafette Optimis√©s",
    data=excel_buffer,
    file_name=path_optimized,
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)

# --- Mise √† jour dans session_state pour la section 5 ---
st.session_state.df_voyages = df_optimized_estafettes


# =====================================================
# 5Ô∏è‚É£ TRANSFERT DES BLs ENTRE ESTAFETTES / CAMIONS
# =====================================================
st.markdown("## üîÅ Transfert de BLs entre Estafettes / Camions")

MAX_POIDS = 1550  # kg
MAX_VOLUME = 4.608  # m¬≥

if "df_voyages" not in st.session_state:
    st.warning("‚ö†Ô∏è Vous devez d'abord ex√©cuter la section 3 (r√©sultat final apr√®s location).")
elif "df_livraisons" not in st.session_state:
    st.warning("‚ö†Ô∏è Le DataFrame des livraisons d√©taill√©es n'est pas disponible.")
else:
    df_voyages = st.session_state.df_voyages.copy()
    df_livraisons = st.session_state.df_livraisons.copy()

    colonnes_requises = ["Zone", "V√©hicule N¬∞", "Poids total charg√©", "Volume total charg√©", "BL inclus"]

    if not all(col in df_voyages.columns for col in colonnes_requises):
        st.error(f"‚ùå Le DataFrame ne contient pas toutes les colonnes n√©cessaires : {', '.join(colonnes_requises)}")
    else:
        zones_disponibles = sorted(df_voyages["Zone"].dropna().unique().tolist())
        zone_selectionnee = st.selectbox("üåç S√©lectionner une zone", zones_disponibles)

        if zone_selectionnee:
            df_zone = df_voyages[df_voyages["Zone"] == zone_selectionnee]
            vehicules = sorted(df_zone["V√©hicule N¬∞"].dropna().unique().tolist())

            col1, col2 = st.columns(2)
            with col1:
                source = st.selectbox("üöê Estafette / Camion source", vehicules)
            with col2:
                cible = st.selectbox("üéØ Estafette / Camion cible", [v for v in vehicules if v != source])

            if source and cible:
                df_source = df_zone[df_zone["V√©hicule N¬∞"] == source]
                if df_source.empty or df_source["BL inclus"].isna().all():
                    st.warning("‚ö†Ô∏è Aucun BL trouv√© pour ce v√©hicule source.")
                else:
                    st.subheader(f"üì¶ BLs actuellement assign√©s √† {source}")

                    # --- Affichage format√© pour Streamlit ---
                    df_source_display = df_source[["V√©hicule N¬∞", "Poids total charg√©", "Volume total charg√©", "BL inclus"]].copy()
                    df_source_display["Poids total charg√©"] = df_source_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
                    df_source_display["Volume total charg√©"] = df_source_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
                    show_df(df_source_display, use_container_width=True)

                    bls_disponibles = df_source["BL inclus"].iloc[0].split(";")
                    bls_selectionnes = st.multiselect("üìã S√©lectionner les BLs √† transf√©rer :", bls_disponibles)

                    if bls_selectionnes and st.button("üîÅ Ex√©cuter le transfert"):

                        df_bls_selection = df_livraisons[df_livraisons["No livraison"].isin(bls_selectionnes)]
                        poids_bls = df_bls_selection["Poids total"].sum()
                        volume_bls = df_bls_selection["Volume total"].sum()

                        df_cible = df_zone[df_zone["V√©hicule N¬∞"] == cible]
                        poids_cible = df_cible["Poids total charg√©"].sum()
                        volume_cible = df_cible["Volume total charg√©"].sum()

                        if (poids_cible + poids_bls) > MAX_POIDS or (volume_cible + volume_bls) > MAX_VOLUME:
                            st.warning("‚ö†Ô∏è Le transfert d√©passe les limites de poids ou volume du v√©hicule cible.")
                        else:
                            def transfer_bl(row):
                                bls = row["BL inclus"].split(";") if pd.notna(row["BL inclus"]) else []
                                bls_to_move = [b for b in bls if b in bls_selectionnes]

                                if row["V√©hicule N¬∞"] == source:
                                    new_bls = [b for b in bls if b not in bls_to_move]
                                    row["BL inclus"] = ";".join(new_bls)
                                    row["Poids total charg√©"] = max(0, row["Poids total charg√©"] - poids_bls)
                                    row["Volume total charg√©"] = max(0, row["Volume total charg√©"] - volume_bls)
                                elif row["V√©hicule N¬∞"] == cible:
                                    new_bls = bls + bls_to_move
                                    row["BL inclus"] = ";".join(new_bls)
                                    row["Poids total charg√©"] += poids_bls
                                    row["Volume total charg√©"] += volume_bls
                                return row

                            df_voyages = df_voyages.apply(transfer_bl, axis=1)
                            st.session_state.df_voyages = df_voyages
                            st.success(f"‚úÖ Transfert r√©ussi : {len(bls_selectionnes)} BL(s) d√©plac√©(s) de {source} vers {cible}.")

                            # --- Affichage Streamlit ---
                            st.subheader("üìä Voyages apr√®s transfert (toutes les zones)")
                            df_display = df_voyages.sort_values(by=["Zone", "V√©hicule N¬∞"]).copy()
                            df_display["Poids total charg√©"] = df_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
                            df_display["Volume total charg√©"] = df_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
                            show_df(df_display[colonnes_requises], use_container_width=True)

                            # --- Export Excel arrondi ---
                            df_export = df_voyages.copy()
                            df_export["Poids total charg√©"] = df_export["Poids total charg√©"].round(3)
                            df_export["Volume total charg√©"] = df_export["Volume total charg√©"].round(3)

                            from io import BytesIO
                            excel_buffer = BytesIO()
                            with pd.ExcelWriter(excel_buffer, engine='openpyxl') as writer:
                                df_export.to_excel(writer, index=False, sheet_name='Transfert BLs')
                            excel_buffer.seek(0)

                            st.download_button(
                                label="üíæ T√©l√©charger le tableau mis √† jour (XLSX)",
                                data=excel_buffer,
                                file_name="voyages_apres_transfert.xlsx",
                                mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                            )

                   

# =====================================================
# 6Ô∏è‚É£ VALIDATION DES VOYAGES APR√àS TRANSFERT
# =====================================================
st.markdown("## ‚úÖ VALIDATION DES VOYAGES APR√àS TRANSFERT")


from io import BytesIO

# --- Fonction pour exporter DataFrame en Excel avec arrondi ---
def to_excel(df, sheet_name="Voyages Valid√©s"):
    df_export = df.copy()
    if "Poids total charg√©" in df_export.columns:
        df_export["Poids total charg√©"] = df_export["Poids total charg√©"].round(3)
    if "Volume total charg√©" in df_export.columns:
        df_export["Volume total charg√©"] = df_export["Volume total charg√©"].round(3)

    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df_export.to_excel(writer, index=False, sheet_name=sheet_name)
    return output.getvalue()

# --- Cr√©ation du DataFrame de validation √† partir du df_voyages ---
voyages_apres_transfert = st.session_state.df_voyages.copy()
df_validation = voyages_apres_transfert.copy()

if "validations" not in st.session_state:
    st.session_state.validations = {}




# --- Affichage interactif des voyages ---
for idx, row in df_validation.iterrows():
    with st.expander(f"üöö Voyage {row['V√©hicule N¬∞']} | Zone : {row['Zone']}"):
        st.write("**Informations du voyage :**")
        row_display = row.to_frame().T.copy()
        if "Poids total charg√©" in row_display.columns:
            row_display["Poids total charg√©"] = row_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
        if "Volume total charg√©" in row_display.columns:
            row_display["Volume total charg√©"] = row_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
        show_df(row_display, use_container_width=True)

        choix = st.radio(
            f"Valider ce voyage ? (Estafette {row['V√©hicule N¬∞']})",
            ["Oui", "Non"],
            index=0 if st.session_state.validations.get(idx) == "Oui" 
                  else 1 if st.session_state.validations.get(idx) == "Non" 
                  else 0,
            key=f"validation_{idx}"
        )
        st.session_state.validations[idx] = choix

# --- Bouton pour appliquer les validations ---
if st.button("üßÆ Appliquer la validation"):
    valid_indexes = [i for i, v in st.session_state.validations.items() if v == "Oui"]
    valid_indexes = [i for i in valid_indexes if i in df_validation.index]

    df_voyages_valides = df_validation.loc[valid_indexes].reset_index(drop=True)
    st.session_state.df_voyages_valides = df_voyages_valides

    st.success(f"‚úÖ {len(df_voyages_valides)} voyage(s) valid√©(s).")
    st.markdown("### üì¶ Voyages Valid√©s")

    # --- Affichage Streamlit avec unit√©s ---
    df_display = df_voyages_valides.copy()
    if "Poids total charg√©" in df_display.columns:
        df_display["Poids total charg√©"] = df_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
    if "Volume total charg√©" in df_display.columns:
        df_display["Volume total charg√©"] = df_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
    show_df(df_display, use_container_width=True)

    # --- Export Excel arrondi ---
    excel_data = to_excel(df_voyages_valides)
    st.download_button(
        label="üíæ T√©l√©charger les voyages valid√©s (XLSX)",
        data=excel_data,
        file_name="Voyages_valides.xlsx",
        mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )

# =====================================================
# 7Ô∏è‚É£ ATTRIBUTION DES V√âHICULES ET CHAUFFEURS
# =====================================================
st.markdown("## üöõ ATTRIBUTION DES V√âHICULES ET CHAUFFEURS")

if 'df_voyages_valides' in st.session_state and not st.session_state.df_voyages_valides.empty:

    df_attribution = st.session_state.df_voyages_valides.copy()

    if "attributions" not in st.session_state:
        st.session_state.attributions = {}

    

    for idx, row in df_attribution.iterrows():
        with st.expander(f"üöö Voyage {row['V√©hicule N¬∞']} | Zone : {row['Zone']}"):
            st.write("**Informations du voyage :**")
            row_display = row.to_frame().T.copy()
            if "Poids total charg√©" in row_display.columns:
                row_display["Poids total charg√©"] = row_display["Poids total charg√©"].map(lambda x: f"{x:.2f} kg")
            if "Volume total charg√©" in row_display.columns:
                row_display["Volume total charg√©"] = row_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
            show_df(row_display, use_container_width=True)

            vehicule_selectionne = st.selectbox(
                f"V√©hicule pour le voyage {row['V√©hicule N¬∞']}",
                VEHICULES_DISPONIBLES,
                index=0 if st.session_state.attributions.get(idx, {}).get("V√©hicule") else 0,
                key=f"vehicule_{idx}"
            )
            chauffeur_selectionne = st.selectbox(
                f"Chauffeur pour le voyage {row['V√©hicule N¬∞']}",
                list(CHAUFFEURS_DETAILS.values()),
                index=0 if st.session_state.attributions.get(idx, {}).get("Chauffeur") else 0,
                key=f"chauffeur_{idx}"
            )

            st.session_state.attributions[idx] = {
                "V√©hicule": vehicule_selectionne,
                "Chauffeur": chauffeur_selectionne
            }

    if st.button("‚úÖ Appliquer les attributions"):

        df_attribution["V√©hicule attribu√©"] = df_attribution.index.map(lambda i: st.session_state.attributions[i]["V√©hicule"])
        df_attribution["Chauffeur attribu√©"] = df_attribution.index.map(lambda i: st.session_state.attributions[i]["Chauffeur"])

        
        st.markdown("### üì¶ Voyages avec V√©hicule et Chauffeur")

        # --- Affichage format√© ---
        df_display = df_attribution.copy()
        if "Poids total charg√©" in df_display.columns:
            df_display["Poids total charg√©"] = df_display["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
        if "Volume total charg√©" in df_display.columns:
            df_display["Volume total charg√©"] = df_display["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")
        show_df(df_display, use_container_width=True)

        # --- Export Excel ---
        from io import BytesIO
        def to_excel(df):
            df_export = df.copy()
            if "Poids total charg√©" in df_export.columns:
                df_export["Poids total charg√©"] = df_export["Poids total charg√©"].round(3)
            if "Volume total charg√©" in df_export.columns:
                df_export["Volume total charg√©"] = df_export["Volume total charg√©"].round(3)
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df_export.to_excel(writer, index=False, sheet_name='Voyages_Attribu√©s')
            return output.getvalue()

        st.download_button(
            label="üíæ T√©l√©charger le tableau final (XLSX)",
            data=to_excel(df_attribution),
            file_name="Voyages_attribues.xlsx",
            mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )

        # --- Export PDF corrig√© ---
        from fpdf import FPDF

        def to_pdf(df, title="Voyages Attribu√©s"):
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", 'B', 14)
            pdf.cell(0, 10, title, ln=True, align="C")
            pdf.ln(5)

            pdf.set_font("Arial", '', 10)

            # Cr√©er une copie format√©e pour le PDF avec unit√©s
            df_pdf = df.copy()
            if "Poids total charg√©" in df_pdf.columns:
                df_pdf["Poids total charg√©"] = df_pdf["Poids total charg√©"].map(lambda x: f"{x:.3f} kg")
            if "Volume total charg√©" in df_pdf.columns:
                df_pdf["Volume total charg√©"] = df_pdf["Volume total charg√©"].map(lambda x: f"{x:.3f} m¬≥")

            col_widths = [pdf.get_string_width(col)+6 for col in df_pdf.columns]

            # En-t√™tes
            for i, col in enumerate(df_pdf.columns):
                pdf.cell(col_widths[i], 8, str(col), border=1, align='C')
            pdf.ln()

            # Lignes
            for _, row in df_pdf.iterrows():
                for i, col in enumerate(df_pdf.columns):
                    pdf.cell(col_widths[i], 8, str(row[col]), border=1)
                pdf.ln()

            return pdf.output(dest='S').encode('latin1')

        st.download_button(
            label="üìÑ T√©l√©charger le tableau final (PDF)",
            data=to_pdf(df_attribution),
            file_name="Voyages_attribues.pdf",
            mime='application/pdf'
        )

