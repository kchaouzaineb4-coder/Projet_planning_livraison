Backend .PY


import pandas as pd
import math
import numpy as np # Import pour g√©rer les NaN plus efficacement

# --- Constantes pour la location de camion ---
SEUIL_POIDS = 3000.0    # kg
SEUIL_VOLUME = 9.216    # m¬≥ (ex: 2.4 * 2.4 * 0.8 * 2 = 9.216)
CAMION_CODE = "CAMION-LOUE"

class TruckRentalProcessor:
    """
    Classe pour g√©rer la logique de proposition et de d√©cision de location de camion
    bas√©e sur les donn√©es optimis√©es.
    """
    
    def __init__(self, df_optimized):
        """Initialise le processeur avec le DataFrame de base pour la gestion des propositions."""
        self.df_base = self._initialize_rental_columns(df_optimized.copy())

    def _initialize_rental_columns(self, df):
        """Ajoute les colonnes d'√©tat de location si elles n'existent pas."""
        # Les colonnes de location sont initialis√©es √† False/vide
        df["Location_camion"] = False
        df["Location_proposee"] = False
        df["Code V√©hicule"] = ""
        # Renomme les colonnes importantes pour les rendre coh√©rentes avec le front-end
        df.rename(columns={
            "Poids total charg√©": "Poids total",
            "Volume total charg√©": "Volume total",
            "Client(s) inclus": "Client commande", # Le nom Client commande est plus parlant pour le front-end
            "Repr√©sentant(s) inclus": "Repr√©sentant"
        }, inplace=True)
        # Ajout des colonnes pour les futures mises √† jour
        df["Camion N¬∞"] = "√Ä Optimiser" # Temporaire pour garder la structure
        
        # S'assurer que les BLs sont bien des cha√Ænes
        df['BL inclus'] = df['BL inclus'].astype(str)
        
        # R√©initialise les BL inclus, le Client commande et le Repr√©sentant pour ne contenir
        # qu'un seul client/repr√©sentant si possible, ou les garder tels quels si plusieurs BLs ont √©t√© agr√©g√©s
        # NOTA : Dans le cas du tableau optimis√©, chaque ligne est une estafette regroupant un ou plusieurs BLs.
        # Pour la d√©tection de proposition, on doit regrouper PAR CLIENT.
        
        return df

    def detecter_propositions(self):
        """
        Regroupe les donn√©es par Client commande pour d√©terminer si le SEUIL est d√©pass√©.
        Retourne un DataFrame des clients proposables.
        """
        # Utiliser df_base pour l'agr√©gation
        grouped = self.df_base.groupby("Client commande").agg(
            Poids_sum=pd.NamedAgg(column="Poids total", aggfunc="sum"),
            Volume_sum=pd.NamedAgg(column="Volume total", aggfunc="sum"),
            Zones=pd.NamedAgg(column="Zone", aggfunc=lambda s: ", ".join(sorted(set(s.astype(str).tolist()))))
        ).reset_index()

        # Filtrage : Poids ou Volume d√©passe le seuil
        propositions = grouped[(grouped["Poids_sum"] >= SEUIL_POIDS) | (grouped["Volume_sum"] >= SEUIL_VOLUME)].copy()

        # Cr√©ation de la colonne Raison
        def get_raison(row):
            raisons = []
            if row["Poids_sum"] >= SEUIL_POIDS:
                raisons.append(f"Poids ‚â• {SEUIL_POIDS} kg")
            if row["Volume_sum"] >= SEUIL_VOLUME:
                raisons.append(f"Volume ‚â• {SEUIL_VOLUME:.3f} m¬≥")
            return " & ".join(raisons)

        propositions["Raison"] = propositions.apply(get_raison, axis=1)
        propositions.rename(columns={
             "Client commande": "Client",
             "Poids_sum": "Poids total (kg)",
             "Volume_sum": "Volume total (m¬≥)",
             "Zones": "Zones concern√©es"
         }, inplace=True)

        return propositions.sort_values(["Poids total (kg)", "Volume total (m¬≥)"], ascending=False).reset_index(drop=True)

    def get_details_client(self, client):
        """R√©cup√®re et formate les d√©tails de tous les BLs/voyages pour un client."""
        data = self.df_base[self.df_base["Client commande"] == client].copy()
        
        if data.empty:
            return f"Aucune donn√©e pour {client}", pd.DataFrame()

        total_poids = data["Poids total"].sum()
        total_volume = data["Volume total"].sum()
        
        # D√©terminer l'√©tat actuel pour ce client
        etat = "Non d√©cid√©e"
        if (data["Location_camion"] == True).all():
            etat = "Location ACCEPT√âE"
        elif (data["Location_proposee"] == False).all() and (data["Location_camion"] == False).all():
            etat = "Non d√©cid√©e"
        elif (data["Location_proposee"] == True).all() and (data["Location_camion"] == False).all():
             etat = "Proposition REFUS√âE"

        # Colonnes pour l'affichage des d√©tails (adapt√©es au DataFrame optimis√©)
        colonnes_affichage = [
            "Zone", "Camion N¬∞", "Poids total", "Volume total", "BL inclus", "Taux d'occupation (%)",
            "Client commande", "Repr√©sentant", "Location_camion", "Location_proposee", "Code V√©hicule"
        ]
        
        # R√©organiser et s√©lectionner les colonnes
        data_display = data[[col for col in colonnes_affichage if col in data.columns]]
        
        resume = f"Client {client} ‚Äî Poids total : {total_poids:.1f} kg ; Volume total : {total_volume:.3f} m¬≥ | √âtat : {etat}"
        
        # Formater les colonnes pour l'affichage
        data_display = data_display.style.format({
            "Poids total": "{:.2f} kg",
            "Volume total": "{:.3f} m¬≥",
            "Taux d'occupation (%)": "{:.2f}%"
        }).set_table_attributes('data-table-name="details-client-table"') # Ajout d'attribut pour Streamlit

        return resume, data_display

    def appliquer_location(self, client, accepter):
        """Applique ou refuse la location pour un client et met √† jour le DataFrame de base."""
        mask = self.df_base["Client commande"] == client
        if not mask.any():
            return False, "Client introuvable.", self.df_base

        df = self.df_base.copy()
        
        # R√©cup√©rer les donn√©es totales (somme de tous les voyages du client)
        poids_total = df.loc[mask, "Poids total"].sum()
        volume_total = df.loc[mask, "Volume total"].sum()
        bl_concat = ";".join(df.loc[mask, "BL inclus"].astype(str))
        representants = ";".join(sorted(df.loc[mask, "Repr√©sentant"].astype(str).unique().tolist()))
        zones = ";".join(sorted(df.loc[mask, "Zone"].astype(str).unique().tolist()))
        estafette_nums = ";".join(df.loc[mask, "Estafette N¬∞"].astype(str).unique().tolist())
        
        # Taux d'occupation
        taux_occu = max(poids_total / SEUIL_POIDS * 100, volume_total / SEUIL_VOLUME * 100)
        
        if accepter:
            # Cr√©er un nouveau voyage (une seule ligne) pour le camion lou√©
            new_row = pd.DataFrame([{
                "Zone": zones,
                "Estafette N¬∞": 9999, # Num√©ro bidon
                "Poids total": poids_total,
                "Volume total": volume_total,
                "BL inclus": bl_concat,
                "Client commande": client,
                "Repr√©sentant": representants,
                "Location_camion": True,
                "Location_proposee": True,
                "Code V√©hicule": CAMION_CODE,
                "Camion N¬∞": "C1", # Camion lou√©
                "Taux d'occupation (%)": taux_occu,
                # Garder les autres colonnes pour compatibilit√© si elles existent
            }])
            
            # Supprimer les lignes d'estafette existantes pour ce client
            df = df[~mask]
            
            # Ajouter la nouvelle ligne
            df = pd.concat([df, new_row], ignore_index=True)
            
            self.df_base = df
            return True, f"‚úÖ Camion lou√© (C1) pour le client {client}. Les {estafette_nums} estafettes ont √©t√© regroup√©es.", self.detecter_propositions()
        else:
            # Refuser la proposition (remettre √† l'optimisation)
            df.loc[mask, ["Location_proposee", "Location_camion", "Code V√©hicule", "Camion N¬∞"]] = [True, False, "", "√Ä Optimiser"]
            self.df_base = df
            return True, f"‚ùå Proposition refus√©e pour le client {client}. Les commandes restent dans leurs estafettes initiales ({estafette_nums}).", self.detecter_propositions()

    def get_df_result(self):
        """Retourne le DataFrame optimis√© final avec les modifications de location."""
        # Renommer les colonnes pour les rendre conformes √† l'affichage final
        df_result = self.df_base.rename(columns={
            "Poids total": "Poids total charg√©",
            "Volume total": "Volume total charg√©",
            "Client commande": "Client(s) inclus",
            "Repr√©sentant": "Repr√©sentant(s) inclus"
        })
        
        # S'assurer que les colonnes finales sont pr√©sentes
        final_cols = [
            "Zone", "Estafette N¬∞", "Poids total charg√©", "Volume total charg√©", 
            "Client(s) inclus", "Repr√©sentant(s) inclus", "BL inclus", "Taux d'occupation (%)",
            "Location_camion", "Location_proposee", "Code V√©hicule", "Camion N¬∞"
        ]
        
        return df_result[[col for col in final_cols if col in df_result.columns]]


class DeliveryProcessor:

    # ... (les m√©thodes _load_livraisons, _load_ydlogist, _load_wcliegps, _filter_initial_data, 
    # _calculate_weights, _calculate_volumes, _merge_delivery_data, _add_city_client_info,
    # _group_data, _calculate_estafette_need, _add_zone, _group_by_zone sont inchang√©es) ...

    # =====================================================
    # ‚úÖ Fonction principale : traitement complet
    # =====================================================
    def process_delivery_data(self, liv_file, ydlogist_file, wcliegps_file):
        try:
            # Lecture des fichiers
            df_liv = self._load_livraisons(liv_file)
            df_yd = self._load_ydlogist(ydlogist_file)

            # Filtrage des donn√©es
            df_liv = self._filter_initial_data(df_liv)

            # Calcul Poids & Volume
            df_poids = self._calculate_weights(df_liv)
            df_vol = self._calculate_volumes(df_liv, df_yd)

            # Fusionner poids + volume
            df_merged = self._merge_delivery_data(df_poids, df_vol)

            # Charger le fichier clients/repr√©sentants
            df_clients = self._load_wcliegps(wcliegps_file)

            # Ajouter Client, Ville et Repr√©sentant
            df_final = self._add_city_client_info(df_merged, df_clients)

            # Calcul Volume total en m3
            df_final["Volume de l'US"] = pd.to_numeric(df_final["Volume de l'US"], errors='coerce').fillna(0) / 1_000_000
            df_final["Volume total"] = df_final["Volume de l'US"] * df_final["Quantit√© livr√©e US"]

            # Regroupement par ville et client
            df_grouped, df_city = self._group_data(df_final)

            # Calcul du besoin en estafette par ville
            df_city = self._calculate_estafette_need(df_city)

            # Nouveau tableau : ajout Zone
            df_grouped_zone = self._add_zone(df_grouped)

            # Filtrer les livraisons avec "Zone inconnue"
            df_grouped_zone = df_grouped_zone[df_grouped_zone["Zone"] != "Zone inconnue"].copy()
            
            # Pr√©parer le dataframe pour l'optimisation en s'assurant que la colonne 'Client' et 'Repr√©sentant' est l√†
            df_grouped_zone = df_grouped_zone.rename(columns={"Client": "Client de l'estafette"})

            # üÜï Groupement par zone
            df_zone = self._group_by_zone(df_grouped_zone)
            
            # üÜï Calcul du besoin en estafette par zone
            df_zone = self._calculate_estafette_need(df_zone)

            # üÜï Calcul des voyages optimis√©s 
            df_optimized_estafettes = self._calculate_optimized_estafette(df_grouped_zone)

            # üÜï Retourne les DataFrames + l'instance TruckRentalProcessor
            return df_grouped, df_city, df_grouped_zone, df_zone, df_optimized_estafettes

        except Exception as e:
            raise Exception(f"‚ùå Erreur lors du traitement des donn√©es : {str(e)}")

    # =====================================================
    # üîπ Chargement des donn√©es
    # =====================================================
    def _load_livraisons(self, liv_file):
        df = pd.read_excel(liv_file)
        
        # ‚úÖ CORRECTION BUG : Renommer la colonne 'N¬∞ BON LIVRAISON' en 'No livraison'
        if 'N¬∞ BON LIVRAISON' in df.columns:
            df.rename(columns={'N¬∞ BON LIVRAISON': 'No livraison'}, inplace=True)
            
        # Renommage de la 5√®me colonne (index 4) en 'Quantit√© livr√©e US'
        if len(df.columns) > 4:
            df.rename(columns={df.columns[4]: "Quantit√© livr√©e US"}, inplace=True)
            
        return df

    def _load_ydlogist(self, file_path):
        df = pd.read_excel(file_path)
        # Renommage des colonnes Unit√© Volume (index 16) et Poids de l'US (index 13)
        if len(df.columns) > 16:
            df.rename(columns={df.columns[16]: "Unit√© Volume", df.columns[13]: "Poids de l'US"}, inplace=True)
        return df

    def _load_wcliegps(self, wcliegps_file):
        df_clients = pd.read_excel(wcliegps_file)
        
        # Identifier et renommer la colonne Repr√©sentant (index 16, colonne Q)
        if len(df_clients.columns) > 16:
            df_clients.rename(columns={df_clients.columns[16]: "Repr√©sentant"}, inplace=True)
        
        # S'assurer que les colonnes 'Client' et 'Repr√©sentant' existent pour la jointure
        required_cols = ["Client", "Ville", "Repr√©sentant"]
        for col in required_cols:
            if col not in df_clients.columns:
                   # G√©rer le cas o√π la colonne n'a pas √©t√© trouv√©e √† l'index 16
                raise ValueError(f"La colonne '{col}' est manquante dans le fichier clients. Veuillez v√©rifier le format.")
        
        return df_clients[["Client", "Ville", "Repr√©sentant"]].copy()


    # =====================================================
    # üîπ Filtrage
    # =====================================================
    def _filter_initial_data(self, df):
        clients_exclus = [
            "AMECAP", "SANA", "SOPAL", "SOPALGAZ", "SOPALSERV", "SOPALTEC",
            "SOPALALG", "AQUA", "WINOX", "QUIVEM", "SANISTONE",
            "SOPAMAR", "SOPALAFR", "SOPALINTER"
        ]
        return df[(df["Type livraison"] != "SDC") & (~df["Client commande"].isin(clients_exclus))]

    # =====================================================
    # üîπ Calcul Poids
    # =====================================================
    def _calculate_weights(self, df):
        # Conversion Poids de l'US
        df["Poids de l'US"] = pd.to_numeric(df["Poids de l'US"].astype(str).str.replace(",", ".")
                                             .str.replace(r"[^\d.]", "", regex=True), errors="coerce").fillna(0)
        
        # Conversion Quantit√© livr√©e US
        df["Quantit√© livr√©e US"] = pd.to_numeric(df["Quantit√© livr√©e US"], errors="coerce").fillna(0)
        
        df["Poids total"] = df["Quantit√© livr√©e US"] * df["Poids de l'US"]
        return df[["No livraison", "Article", "Client commande", "Poids total"]]

    # =====================================================
    # üîπ Calcul Volume
    # =====================================================
    def _calculate_volumes(self, df_liv, df_art):
        df_liv_sel = df_liv[["No livraison", "Article", "Quantit√© livr√©e US", "Client commande"]]
        df_art_sel = df_art[["Article", "Volume de l'US", "Unit√© Volume"]].copy()
        
        # Conversion Volume de l'US
        df_art_sel["Volume de l'US"] = pd.to_numeric(df_art_sel["Volume de l'US"].astype(str).str.replace(",", "."),
                                                     errors="coerce")
        return pd.merge(df_liv_sel, df_art_sel, on="Article", how="left")

    # =====================================================
    # üîπ Fusion
    # =====================================================
    def _merge_delivery_data(self, df_poids, df_vol):
        return pd.merge(df_poids, df_vol, on=["No livraison", "Article", "Client commande"], how="left")

    # =====================================================
    # üîπ Ajout Client, Ville et Repr√©sentant
    # =====================================================
    def _add_city_client_info(self, df, df_clients):
        # Jointure pour ajouter Ville et Repr√©sentant
        return pd.merge(df, df_clients[["Client", "Ville", "Repr√©sentant"]],
                          left_on="Client commande", right_on="Client", how="left")

    # =====================================================
    # üîπ Groupement par Livraison/Client/Ville/Repr√©sentant
    # La colonne "Client commande" est maintenant renomm√©e en "Client" ici
    # =====================================================
    def _group_data(self, df):
        # Inclure "Repr√©sentant" dans le regroupement initial par BL
        df_grouped = df.groupby(["No livraison", "Client", "Ville", "Repr√©sentant"], as_index=False).agg({
            "Article": lambda x: ", ".join(x.astype(str)),
            "Poids total": "sum",
            "Volume total": "sum"
        })
        df_city = df_grouped.groupby("Ville", as_index=False).agg({
            "Poids total": "sum",
            "Volume total": "sum",
            "No livraison": "count"
        }).rename(columns={"No livraison": "Nombre livraisons"})
        return df_grouped, df_city

    # =====================================================
    # üîπ Calcul besoin estafette (Applicable √† Ville ou Zone)
    # =====================================================
    def _calculate_estafette_need(self, df):
        poids_max = 1550 # kg
        volume_max = 1.2 * 1.2 * 0.8 * 4 # m3 (4.608)
        
        if "Poids total" in df.columns and "Volume total" in df.columns:
            df["Besoin estafette (poids)"] = df["Poids total"].apply(lambda p: math.ceil(p / poids_max))
            df["Besoin estafette (volume)"] = df["Volume total"].apply(lambda v: math.ceil(v / volume_max))
            df["Besoin estafette r√©el"] = df[["Besoin estafette (poids)", "Besoin estafette (volume)"]].max(axis=1)
        else:
            print("Colonnes Poids total ou Volume total manquantes pour le calcul estafette.")
        return df

    # =====================================================
    # üîπ Ajout Zone
    # =====================================================
    def _add_zone(self, df):
        zones = {
            "Zone 1": ["TUNIS", "ARIANA", "MANOUBA", "BEN AROUS", "BIZERTE", "MATEUR",
                       "MENZEL BOURGUIBA", "UTIQUE"],
            "Zone 2": ["NABEUL", "HAMMAMET", "KORBA", "MENZEL TEMIME", "KELIBIA", "SOLIMAN"],
            "Zone 3": ["SOUSSE", "MONASTIR", "MAHDIA", "KAIROUAN"],
            "Zone 4": ["GAB√àS", "MEDENINE", "ZARZIS", "DJERBA"],
            "Zone 5": ["GAFSA", "KASSERINE", "TOZEUR", "NEFTA", "DOUZ"],
            "Zone 6": ["JENDOUBA", "B√âJA", "LE KEF", "TABARKA", "SILIANA"],
            "Zone 7": ["SFAX"]
        }

        def get_zone(ville):
            ville = str(ville).upper().strip()
            for z, villes in zones.items():
                if ville in villes:
                    return z
            return "Zone inconnue"

        df["Zone"] = df["Ville"].apply(get_zone)
        return df

    # =====================================================
    # üÜï Groupement par Zone
    # =====================================================
    def _group_by_zone(self, df_grouped_zone):
        df_zone = df_grouped_zone.groupby("Zone", as_index=False).agg({
            "Poids total": "sum",
            "Volume total": "sum",
            "No livraison": "count"
        }).rename(columns={"No livraison": "Nombre livraisons"})
        return df_zone

    # =====================================================
    # üÜï Calcul des voyages optimis√©s par Estafette (Bin Packing 1D/2D Heuristique)
    # =====================================================
    def _calculate_optimized_estafette(self, df_grouped_zone):
        # === Capacit√©s max ===
        MAX_POIDS = 1550    # kg
        MAX_VOLUME = 4.608  # m3 (1.2 * 1.2 * 0.8 * 4)

        resultats = []
        estafette_num = 1  # compteur global unique

        # === Boucle par zone ===
        for zone, group in df_grouped_zone.groupby("Zone"):
            # Trier les BL par poids d√©croissant (heuristique First Fit Decreasing)
            group_sorted = group.sort_values(by="Poids total", ascending=False).reset_index()

            estafettes = []  # liste des estafettes d√©j√† cr√©√©es pour la zone

            for idx, row in group_sorted.iterrows():
                bl = str(row["No livraison"])
                poids = row["Poids total"]
                volume = row["Volume total"]
                client = str(row["Client de l'estafette"]) 
                representant = str(row["Repr√©sentant"])

                placed = False

                # Chercher la 1√®re estafette o√π √ßa rentre
                for e in estafettes:
                    if e["poids"] + poids <= MAX_POIDS and e["volume"] + volume <= MAX_VOLUME:
                        e["poids"] += poids
                        e["volume"] += volume
                        e["bls"].append(bl)
                        # Ajout du client/repr√©sentant √† l'ensemble (set) pour l'unicit√©
                        for c in client.split(','): e["clients"].add(c.strip())
                        for r in representant.split(','): e["representants"].add(r.strip())
                        placed = True
                        break

                # Si aucun emplacement trouv√© -> cr√©er une nouvelle estafette
                if not placed:
                    estafettes.append({
                        "poids": poids,
                        "volume": volume,
                        "bls": [bl],
                        "clients": {c.strip() for c in client.split(',')},
                        "representants": {r.strip() for r in representant.split(',')} 
                    })

            # Sauvegarder les r√©sultats avec num√©rotation continue
            for e in estafettes:
                clients_list = ", ".join(sorted(list(e["clients"])))
                representants_list = ", ".join(sorted(list(e["representants"])))
                
                resultats.append([
                    zone,
                    estafette_num,  # num√©ro global
                    e["poids"],
                    e["volume"],
                    clients_list,   
                    representants_list,
                    ";".join(e["bls"])
                ])
                estafette_num += 1  # on incr√©mente √† chaque nouvelle estafette

            # === Cr√©er un DataFrame r√©sultat ===
        df_estafettes = pd.DataFrame(resultats, columns=["Zone", "Estafette N¬∞", "Poids total charg√©", "Volume total charg√©", "Client(s) inclus", "Repr√©sentant(s) inclus", "BL inclus"])

        # CALCUL DU TAUX D'OCCUPATION
        df_estafettes["Taux Poids (%)"] = (df_estafettes["Poids total charg√©"] / MAX_POIDS) * 100
        df_estafettes["Taux Volume (%)"] = (df_estafettes["Volume total charg√©"] / MAX_VOLUME) * 100

        df_estafettes["Taux d'occupation (%)"] = df_estafettes[["Taux Poids (%)", "Taux Volume (%)"]].max(axis=1).round(2)

        # Nettoyage et formatage final
        df_estafettes = df_estafettes.drop(columns=["Taux Poids (%)", "Taux Volume (%)"]) 
        
        return df_estafettes



APP.PY


import streamlit as st
import pandas as pd
from backend import DeliveryProcessor, TruckRentalProcessor, SEUIL_POIDS, SEUIL_VOLUME
import plotly.express as px

# Configuration page
st.set_page_config(page_title="Planning Livraisons", layout="wide")
st.title("üöö Planning de Livraisons")

# =====================================================
# INITIALISATION DE L'√âTAT DE SESSION
# =====================================================
if 'data_processed' not in st.session_state:
    st.session_state.data_processed = False
    st.session_state.df_grouped = None
    st.session_state.df_city = None
    st.session_state.df_grouped_zone = None
    st.session_state.df_zone = None 
    st.session_state.df_optimized_estafettes = None
    st.session_state.rental_processor = None # üÜï Objet de traitement de location
    st.session_state.propositions = None # üÜï Dataframe de propositions
    st.session_state.selected_client = None # üÜï Client s√©lectionn√©
    st.session_state.message = "" # üÜï Message de r√©sultat d'op√©ration

# =====================================================
# Fonctions de Callback pour la Location
# =====================================================

def update_propositions_view():
    """Met √† jour le DataFrame de propositions apr√®s une action."""
    if st.session_state.rental_processor:
        st.session_state.propositions = st.session_state.rental_processor.detecter_propositions()
        # R√©initialiser la s√©lection si le client n'est plus dans les propositions ouvertes
        if st.session_state.selected_client and st.session_state.selected_client not in st.session_state.propositions['Client'].tolist():
             st.session_state.selected_client = None
    else:
        st.session_state.propositions = pd.DataFrame()

def handle_location_action(accepter):
    """G√®re l'acceptation ou le refus de la proposition de location."""
    if st.session_state.rental_processor and st.session_state.selected_client:
        ok, msg, _ = st.session_state.rental_processor.appliquer_location(
            st.session_state.selected_client, accepter=accepter
        )
        st.session_state.message = msg
        update_propositions_view()
    elif not st.session_state.selected_client:
        st.session_state.message = "‚ö†Ô∏è Veuillez s√©lectionner un client √† traiter."
    else:
        st.session_state.message = "‚ö†Ô∏è Le processeur de location n'est pas initialis√©."

def accept_location_callback():
    handle_location_action(True)

def refuse_location_callback():
    handle_location_action(False)

# =====================================================
# Logique de Traitement (Se d√©clenche et stocke les r√©sultats)
# =====================================================
col_file_1, col_file_2, col_file_3, col_button = st.columns([1, 1, 1, 1])
with col_file_1:
    liv_file = st.file_uploader("Fichier Livraisons", type=["xlsx"])
with col_file_2:
    ydlogist_file = st.file_uploader("Fichier Volumes", type=["xlsx"])
with col_file_3:
    wcliegps_file = st.file_uploader("Fichier Clients", type=["xlsx"])
with col_button:
    # Espace pour le bouton
    st.markdown("<br>", unsafe_allow_html=True) # Petit espace
    if st.button("Ex√©cuter le traitement complet", type="primary"):
        if liv_file and ydlogist_file and wcliegps_file:
            processor = DeliveryProcessor()
            try:
                with st.spinner("Traitement des donn√©es en cours..."):
                    df_grouped, df_city, df_grouped_zone, df_zone, df_optimized_estafettes = processor.process_delivery_data(
                        liv_file, ydlogist_file, wcliegps_file
                    )
                
                # Stockage des r√©sultats dans l'√©tat de session
                st.session_state.df_optimized_estafettes = df_optimized_estafettes
                st.session_state.df_grouped = df_grouped
                st.session_state.df_city = df_city
                st.session_state.df_grouped_zone = df_grouped_zone
                st.session_state.df_zone = df_zone 
                
                # üÜï Initialisation du processeur de location et des propositions
                st.session_state.rental_processor = TruckRentalProcessor(df_optimized_estafettes)
                update_propositions_view()
                
                st.session_state.data_processed = True
                st.session_state.message = "Traitement termin√© avec succ√®s !"
                st.rerun() # Rerun pour mettre √† jour l'interface

            except Exception as e:
                st.error(f"‚ùå Erreur lors du traitement : {str(e)}")
                st.session_state.data_processed = False
        else:
            st.warning("Veuillez uploader tous les fichiers n√©cessaires.")
        

# =====================================================
# Logique d'Affichage (Se d√©clenche si les donn√©es sont dans l'√©tat de session)
# =====================================================
if st.session_state.data_processed:
    
    if st.session_state.message.startswith("‚úÖ"):
        st.success(st.session_state.message)
    elif st.session_state.message.startswith("‚ùå"):
        st.error(st.session_state.message)
    elif st.session_state.message.startswith("‚ö†Ô∏è"):
        st.warning(st.session_state.message)
    else:
        st.info(st.session_state.message or "Pr√™t √† traiter les propositions de location.")
        
    df_optimized_estafettes = st.session_state.rental_processor.get_df_result() # R√©cup√©ration du DF mis √† jour
    
    # --- Interface de Location de Camion ---
    st.header("üöö Proposition de location de camion")
    st.markdown(f"üî∏ Si un client d√©passe **{SEUIL_POIDS} kg** ou **{SEUIL_VOLUME} m¬≥**, une location est propos√©e.")

    if st.session_state.propositions is not None and not st.session_state.propositions.empty:
        col_prop, col_details = st.columns([2, 3])
        
        with col_prop:
            st.markdown("### Propositions ouvertes")
            # Affichage des propositions ouvertes
            st.dataframe(st.session_state.propositions, 
                         use_container_width=True,
                         column_order=["Client", "Poids total (kg)", "Volume total (m¬≥)", "Raison"],
                         hide_index=True)
            
            # S√©lection du client
            client_options = [""] + st.session_state.propositions['Client'].astype(str).tolist()
            st.session_state.selected_client = st.selectbox(
                "Client √† traiter :", 
                options=client_options, 
                index=client_options.index(st.session_state.selected_client) if st.session_state.selected_client in client_options else 0,
                key='client_select' # Ajout d'une cl√© pour la session state
            )

            col_btn_acc, col_btn_ref = st.columns(2)
            with col_btn_acc:
                st.button("‚úÖ Accepter la location", 
                          on_click=accept_location_callback, 
                          disabled=not st.session_state.selected_client,
                          use_container_width=True)
            with col_btn_ref:
                st.button("‚ùå Refuser la proposition", 
                          on_click=refuse_location_callback, 
                          disabled=not st.session_state.selected_client,
                          use_container_width=True)

        with col_details:
            st.markdown("### D√©tails de la commande client")
            if st.session_state.selected_client:
                resume, details_df_styled = st.session_state.rental_processor.get_details_client(st.session_state.selected_client)
                st.text(resume)
                # Affichage du DataFrame stylis√©
                st.dataframe(details_df_styled, use_container_width=True, hide_index=True)
            else:
                st.info("S√©lectionnez un client pour afficher les d√©tails de la commande/estafettes.")
    else:
        st.success("üéâ Aucune proposition de location de camion d√©tect√©e pour le moment.")
        
    st.divider() # S√©parateur
    
    # =====================================================
    # Tableau 5 - Voyages par Estafette Optimis√© (Mis √† jour)
    # =====================================================
    st.subheader("Voyages par Estafette Optimis√© (Inclut Camions Lou√©s)")
    
    # Affichage du DataFrame avec formatage
    st.dataframe(df_optimized_estafettes.style.format({
        "Poids total charg√©": "{:.2f} kg",
        "Volume total charg√©": "{:.3f} m¬≥",
        "Taux d'occupation (%)": "{:.2f}%"
    }), use_container_width=True)


    path_optimized = "Voyages_Estafette_Optimises.xlsx"
    # Note: On utilise le DataFrame non format√© en string pour l'export Excel
    df_optimized_estafettes.to_excel(path_optimized, index=False)
    with open(path_optimized, "rb") as f:
        st.download_button(
            label="üíæ T√©l√©charger Voyages Estafette Optimis√©s",
            data=f,
            file_name=path_optimized,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        
    # --- Autres tableaux (Optionnel mais conserv√©) ---
    st.header("Analyse de Livraison D√©taill√©e")
    tab_grouped, tab_city, tab_zone_group, tab_zone_summary, tab_charts = st.tabs([
        "Livraisons Client/Ville", 
        "Besoin Estafette par Ville", 
        "Livraisons Client/Zone", 
        "Besoin Estafette par Zone",
        "Graphiques"
    ])
    
    # ... (le code d'affichage des autres tableaux et graphiques est conserv√© ici)
    with tab_grouped:
        st.subheader("Livraisons par Client & Ville")
        st.dataframe(st.session_state.df_grouped.drop(columns=["Zone"], errors='ignore'))
        
    with tab_city:
        st.subheader("Besoin Estafette par Ville")
        st.dataframe(st.session_state.df_city)

    with tab_zone_group:
        st.subheader("Livraisons par Client & Ville + Zone")
        st.dataframe(st.session_state.df_grouped_zone)
        
    with tab_zone_summary:
        st.subheader("Besoin Estafette par Zone")
        st.dataframe(st.session_state.df_zone)
        
    with tab_charts:
        st.subheader("Statistiques par Ville")
        col1, col2 = st.columns(2)
        with col1:
            st.plotly_chart(px.bar(st.session_state.df_city, x="Ville", y="Poids total",
                                   title="Poids total livr√© par ville"),
                            use_container_width=True)
        with col2:
            st.plotly_chart(px.bar(st.session_state.df_city, x="Ville", y="Volume total",
                                   title="Volume total livr√© par ville (m¬≥)"),
                            use_container_width=True)

        col3, col4 = st.columns(2)
        with col3:
            st.plotly_chart(px.bar(st.session_state.df_city, x="Ville", y="Nombre livraisons",
                                   title="Nombre de livraisons par ville"),
                            use_container_width=True)
        with col4:
            st.plotly_chart(px.bar(st.session_state.df_city, x="Ville", y="Besoin estafette r√©el",
                                   title="Besoin en Estafettes par ville"),
                            use_container_width=True)
